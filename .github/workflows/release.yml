# Release workflow - builds and publishes multi-architecture container images to GitHub Container Registry.
#
# Workflow Overview:
# 1. Build Job (matrix strategy):
#    - Builds architecture-specific images (amd64, arm64) in parallel
#    - Each architecture builds on its native runner on ubuntu-22.04
#    - Images are tagged with version-architecture (e.g., 1.2.3-amd64, 1.2.3-arm)
#    - Tests container image properties (labels, entrypoint, user setup, etc.)
#    - Images are pushed to registry only if tests pass
#
# 2. Manifest Job:
#    - Runs after all build jobs complete successfully
#    - Creates multi-architecture manifests combining amd64 and arm64 images
#    - Creates two manifests:
#      a) Version-specific: ghcr.io/vig-os/devcontainer:1.2.3 (points to both architectures)
#      b) Latest: ghcr.io/vig-os/devcontainer:latest (always points to latest release)
#
# Design Decisions:
# - Separate architecture builds: Better performance (native builds) and clearer failure isolation
# - Architecture-specific tags: Allows users to pull specific architecture if needed
# - Multi-arch manifests: Provides automatic architecture selection for users
# - Latest tag: Always updated to newest release for convenience
# - Concurrency control: Prevents race conditions when multiple tags are pushed simultaneously
#
# Trigger: Pushes to tags matching semantic versioning (vX.Y.Z)

name: Release

on:  # yamllint disable-line rule:truthy
  push:
    tags:
      # Only trigger on semantic version tags (e.g., v1.2.3)
      # Pattern ensures we only build on valid version tags
      - 'v[0-9]+.[0-9]+.[0-9]+'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to build (e.g., 1.2.3-test)'
        required: false
        default: '99.0.1'
        type: string
      publish:
        description: 'Publish images to the registry'
        required: false
        default: false
        type: boolean
      architectures:
        description: 'Architectures to build (comma-separated: amd64,arm64)'
        required: false
        default: 'amd64,arm64'
        type: string

concurrency:
  # Prevent multiple workflows from running simultaneously
  # This avoids race conditions in manifest creation
  group: publish-image
  cancel-in-progress: false  # Queue instead of cancel to ensure all releases are published

permissions:
  contents: read   # Read repository contents for checkout
  packages: write  # Write access to GitHub Container Registry

jobs:
  extract-version:
    # Extract version information once for reuse by all jobs
    # This avoids duplicating the version extraction logic
    runs-on: ubuntu-22.04
    outputs:
      version: ${{ steps.version.outputs.version }}
      release_url: ${{ steps.version.outputs.release_url }}
      release_date: ${{ steps.version.outputs.release_date }}
      build_timestamp: ${{ steps.version.outputs.build_timestamp }}
    steps:
      - name: Extract version from tag
        id: version
        run: |
          # Handle both tag push and manual workflow_dispatch
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
            # For manual dispatch, allow more flexible version formats (e.g., 1.2.3-test)
            if [ -z "$VERSION" ]; then
              echo "ERROR: Version is required for manual dispatch"
              exit 1
            fi
          else
            # Extract from tag (e.g., refs/tags/v1.2.3 -> 1.2.3)
            VERSION=${GITHUB_REF#refs/tags/v}
            # Validate semantic version format for tag pushes
            if ! echo "$VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
              echo "ERROR: Invalid version format '$VERSION'"
              echo "Version must follow semantic versioning format X.Y.Z"
              exit 1
            fi
          fi
          RELEASE_URL="https://github.com/vig-os/devcontainer/releases/tag/v$VERSION"
          RELEASE_DATE=$(date -u +%Y-%m-%d)
          BUILD_TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "release_url=$RELEASE_URL" >> $GITHUB_OUTPUT
          echo "release_date=$RELEASE_DATE" >> $GITHUB_OUTPUT
          echo "build_timestamp=$BUILD_TIMESTAMP" >> $GITHUB_OUTPUT
          echo "Extracted version: $VERSION"

  validate-architectures:
    # Validate and parse architecture inputs
    # Ensures only valid architectures (amd64, arm64) are specified
    runs-on: ubuntu-22.04
    outputs:
      architectures: ${{ steps.parse.outputs.architectures }}
      matrix: ${{ steps.parse.outputs.matrix }}
    steps:
      - name: Parse and validate architectures
        id: parse
        run: |
          set -euo pipefail

          # Get architectures input (default to both for tag pushes)
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ARCHS="${{ github.event.inputs.architectures }}"
          else
            # For tag pushes, always build both architectures
            ARCHS="amd64,arm64"
          fi

          echo "Input architectures: $ARCHS"

          # Remove spaces and convert to array
          ARCHS=$(echo "$ARCHS" | tr -d ' ')
          IFS=',' read -ra ARCH_ARRAY <<< "$ARCHS"

          # Validate each architecture
          VALID_ARCHS="amd64 arm64"
          VALIDATED_ARCHS=()

          for arch in "${ARCH_ARRAY[@]}"; do
            if [[ " $VALID_ARCHS " =~ " $arch " ]]; then
              VALIDATED_ARCHS+=("$arch")
              echo "✓ Valid architecture: $arch"
            else
              echo "ERROR: Invalid architecture '$arch'"
              echo "Valid architectures are: amd64, arm64"
              exit 1
            fi
          done

          # Check for duplicates
          UNIQUE_ARCHS=($(echo "${VALIDATED_ARCHS[@]}" | tr ' ' '\n' | sort -u))
          if [ ${#UNIQUE_ARCHS[@]} -ne ${#VALIDATED_ARCHS[@]} ]; then
            echo "ERROR: Duplicate architectures found"
            exit 1
          fi

          # Generate matrix JSON
          MATRIX_JSON=$(printf '%s\n' "${VALIDATED_ARCHS[@]}" | jq -R . | jq -s -c '{arch: .}')

          echo "Validated architectures: ${VALIDATED_ARCHS[*]}"
          echo "Matrix JSON: $MATRIX_JSON"

          # Output for other jobs
          echo "architectures=${VALIDATED_ARCHS[*]}" >> $GITHUB_OUTPUT
          echo "matrix=$MATRIX_JSON" >> $GITHUB_OUTPUT

  build:
    # Build architecture-specific images in parallel
    # Each architecture builds on its native runner for optimal performance
    needs: [extract-version, validate-architectures]
    timeout-minutes: 60  # Prevent stuck builds from consuming excessive resources
    permissions:
      contents: read
      packages: write

    strategy:
      matrix: ${{ fromJson(needs.validate-architectures.outputs.matrix) }}

    runs-on: ${{ matrix.arch == 'amd64' && 'ubuntu-22.04' || 'ubuntu-22.04-arm' }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6.0.1

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3.6.0
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ github.token }}

      - name: Build container image
        id: build
        uses: ./.github/actions/build-image
        with:
          version: ${{ needs.extract-version.outputs.version }}
          arch: ${{ matrix.arch }}
          release-date: ${{ needs.extract-version.outputs.release_date }}
          release-url: ${{ needs.extract-version.outputs.release_url }}
          build-timestamp: ${{ needs.extract-version.outputs.build_timestamp }}
          vcs-ref: ${{ github.sha }}
          output-type: tar

      - name: Run image tests
        uses: ./.github/actions/test-image
        with:
          image-tag: ${{ needs.extract-version.outputs.version }}-${{ matrix.arch }}
          image-source: tar

      - name: Run integration tests
        uses: ./.github/actions/test-integration
        with:
          image-tag: ${{ needs.extract-version.outputs.version }}-${{ matrix.arch }}

      - name: Load tested image into Docker
        # Load the tar file that was built and tested
        # This ensures we push the exact image that passed all tests
        if: github.event_name != 'workflow_dispatch' || github.event.inputs.publish == 'true'
        run: |
          set -euo pipefail
          TAR_FILE="/tmp/image.tar"

          echo "Loading tested image from $TAR_FILE..."

          if [ ! -f "$TAR_FILE" ]; then
            echo "ERROR: Tar file not found: $TAR_FILE"
            ls -lh /tmp/
            exit 1
          fi

          # Load the tar file into Docker
          docker load < "$TAR_FILE"

          echo "Image loaded successfully"
          docker images

      - name: Push tested image to registry
        # Push the exact image that was tested (not a rebuild)
        # Only runs if tests passed (workflow would have failed otherwise)
        # For workflow_dispatch, push only when inputs.publish=true (default false)
        if: github.event_name != 'workflow_dispatch' || github.event.inputs.publish == 'true'
        run: |
          set -euo pipefail
          REGISTRY_TAG="ghcr.io/vig-os/devcontainer:${{ needs.extract-version.outputs.version }}-${{ matrix.arch }}"

          echo "Pushing tested image to registry: $REGISTRY_TAG"

          # Find the loaded image (it has the registry tag already from build-image action)
          if docker images --format "{{.Repository}}:{{.Tag}}" | grep -q "^$REGISTRY_TAG$"; then
            echo "Image found with correct tag: $REGISTRY_TAG"
          else
            echo "ERROR: Image not found with expected tag: $REGISTRY_TAG"
            echo "Available images:"
            docker images
            exit 1
          fi

          # Retry logic for docker push (network issues)
          RETRIES=3
          for i in $(seq 1 $RETRIES); do
            if docker push "$REGISTRY_TAG"; then
              echo "Image pushed successfully: $REGISTRY_TAG"
              break
            else
              if [ $i -lt $RETRIES ]; then
                echo "Push failed, retrying ($i/$RETRIES)..."
                sleep 3
              else
                echo "ERROR: Push failed after $RETRIES attempts"
                exit 1
              fi
            fi
          done

      - name: Verify image push
        # Verify that the image was successfully pushed to the registry
        # This catches silent push failures that might not be detected otherwise
        # For workflow_dispatch, verify only when inputs.publish=true (default false)
        if: github.event_name != 'workflow_dispatch' || github.event.inputs.publish == 'true'
        run: |
          set -euo pipefail
          IMAGE_TAG="ghcr.io/vig-os/devcontainer:${{ needs.extract-version.outputs.version }}-${{ matrix.arch }}"
          echo "Verifying image was pushed successfully: $IMAGE_TAG"

          # Retry logic for image verification (registry may need time to propagate)
          RETRIES=5
          for i in $(seq 1 $RETRIES); do
            if docker buildx imagetools inspect "$IMAGE_TAG" >/dev/null 2>&1; then
              # Get and display image digest
              DIGEST=$(docker buildx imagetools inspect "$IMAGE_TAG" --format '{{.Manifest.Digest}}' 2>&1 || echo "")
              if [ -n "$DIGEST" ] && [ "$DIGEST" != "null" ]; then
                echo "Image verified successfully"
                echo "Digest: $DIGEST"
              else
                echo "WARNING: Could not retrieve image digest, but image exists"
              fi
              echo "Image push verification complete"
              break
            else
              if [ $i -lt $RETRIES ]; then
                echo "Verification failed, retrying ($i/$RETRIES)..."
                sleep 5
              else
                echo "ERROR: Failed to verify image push after $RETRIES attempts - image not found or not accessible"
                exit 1
              fi
            fi
          done

      - name: Upload build logs
        # Upload build logs for debugging:
        # - On failure (for production tag pushes)
        # - Always for manual dispatch (test mode - useful for debugging test runs)
        # Retention: 7 days (sufficient for post-mortem analysis)
        if: failure() || github.event_name == 'workflow_dispatch'
        uses: actions/upload-artifact@v6.0.0
        with:
          name: build-logs-${{ matrix.arch }}-${{ needs.extract-version.outputs.version }}
          path: |
            **/*.log
          retention-days: 7

  manifest:
    # Multi-Architecture Manifest Creation
    #
    # After architecture-specific images are built and pushed, this job creates
    # multi-architecture manifests that allow users to pull images without
    # specifying an architecture. Docker/Podman automatically selects the
    # correct architecture based on the user's platform.
    #
    # Why separate job?
    # - Build jobs run in parallel on different runners (amd64 vs arm64)
    # - Manifest creation requires all images to exist
    # - Separating concerns makes failure isolation clearer
    #
    # Why verify before creating?
    # - Prevents creating incomplete manifests if one architecture build failed
    # - Provides clear error messages if images are missing
    # - Catches registry push failures early
    needs: [extract-version, validate-architectures, build]
    # For workflow_dispatch, run only when inputs.publish=true (default false)
    if: needs.build.result == 'success' && (github.event_name != 'workflow_dispatch' || github.event.inputs.publish == 'true')
    timeout-minutes: 10  # Manifest operations are fast, short timeout prevents hangs
    runs-on: ubuntu-22.04  # Can run on any runner, no architecture-specific code
    permissions:
      contents: read
      packages: write
    steps:
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3.12.0

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3.6.0
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ github.token }}

      - name: Create and push multi-arch manifest
        # Creates two manifests:
        # 1. Version-specific: ghcr.io/vig-os/devcontainer:VERSION
        # 2. Latest: ghcr.io/vig-os/devcontainer:latest (only for tag pushes)
        # Both point to the architecture-specific images that were built,
        # allowing Docker to automatically select the correct architecture
        run: |
          set -euo pipefail  # Exit on error, undefined vars, pipe failures
          VERSION="${{ needs.extract-version.outputs.version }}"
          REPO="ghcr.io/vig-os/devcontainer"
          ARCHS="${{ needs.validate-architectures.outputs.architectures }}"

          echo "Building manifest for architectures: $ARCHS"

          # Convert space-separated list to array
          IFS=' ' read -ra ARCH_ARRAY <<< "$ARCHS"

          # Verification phase: Ensure all architecture images exist
          # This prevents creating incomplete manifests
          echo "Verifying architecture-specific images exist..."
          ARCH_IMAGES=()
          for arch in "${ARCH_ARRAY[@]}"; do
            IMAGE="$REPO:$VERSION-$arch"
            echo "Checking image: $IMAGE"

            # Retry logic for image verification (registry propagation delay)
            RETRIES=5
            VERIFIED=false
            for i in $(seq 1 $RETRIES); do
              if docker buildx imagetools inspect "$IMAGE" >/dev/null 2>&1; then
                echo "✓ Verified $arch image exists"
                VERIFIED=true
                break
              else
                if [ $i -lt $RETRIES ]; then
                  echo "Image not found, retrying ($i/$RETRIES)..."
                  sleep 5
                fi
              fi
            done

            if [ "$VERIFIED" = "false" ]; then
              echo "ERROR: $arch image not found after $RETRIES attempts: $IMAGE"
              exit 1
            fi

            ARCH_IMAGES+=("$IMAGE")
          done

          # Manifest creation phase: Create version manifest
          echo "Creating version manifest: $REPO:$VERSION"

          # Retry logic for manifest creation (network/registry issues)
          RETRIES=3
          for i in $(seq 1 $RETRIES); do
            if docker buildx imagetools create \
              --tag "$REPO:$VERSION" \
              "${ARCH_IMAGES[@]}"; then
              echo "✓ Created version manifest: $REPO:$VERSION"
              break
            else
              if [ $i -lt $RETRIES ]; then
                echo "Manifest creation failed, retrying ($i/$RETRIES)..."
                sleep 3
              else
                echo "ERROR: Failed to create version manifest after $RETRIES attempts"
                exit 1
              fi
            fi
          done

          # Create/update latest manifest only for tag pushes with both architectures
          if [ "${{ github.event_name }}" != "workflow_dispatch" ] && [ "${#ARCH_ARRAY[@]}" -eq 2 ]; then
            echo "Creating/updating latest manifest: $REPO:latest"

            # Retry logic for latest manifest creation
            RETRIES=3
            for i in $(seq 1 $RETRIES); do
              if docker buildx imagetools create \
                --tag "$REPO:latest" \
                "${ARCH_IMAGES[@]}"; then
                echo "✓ Created/updated latest manifest: $REPO:latest"
                break
              else
                if [ $i -lt $RETRIES ]; then
                  echo "Latest manifest creation failed, retrying ($i/$RETRIES)..."
                  sleep 3
                else
                  echo "ERROR: Failed to create latest manifest after $RETRIES attempts"
                  exit 1
                fi
              fi
            done
          else
            echo "Skipping 'latest' tag (workflow_dispatch or single architecture build)"
          fi

          # Verification phase: Confirm version manifest was created successfully
          echo "Verifying version manifest..."

          # Retry logic for version manifest verification
          RETRIES=5
          for i in $(seq 1 $RETRIES); do
            if docker buildx imagetools inspect "$REPO:$VERSION" >/dev/null 2>&1; then
              echo "✓ Version manifest verified"
              break
            else
              if [ $i -lt $RETRIES ]; then
                echo "Verification failed, retrying ($i/$RETRIES)..."
                sleep 5
              else
                echo "ERROR: Version manifest verification failed after $RETRIES attempts"
                exit 1
              fi
            fi
          done

          # Verify latest manifest if it was created
          if [ "${{ github.event_name }}" != "workflow_dispatch" ] && [ "${#ARCH_ARRAY[@]}" -eq 2 ]; then
            echo "Verifying latest manifest..."

            # Retry logic for latest manifest verification
            RETRIES=5
            for i in $(seq 1 $RETRIES); do
              if docker buildx imagetools inspect "$REPO:latest" >/dev/null 2>&1; then
                echo "✓ Latest manifest verified"
                break
              else
                if [ $i -lt $RETRIES ]; then
                  echo "Verification failed, retrying ($i/$RETRIES)..."
                  sleep 5
                else
                  echo "ERROR: Latest manifest verification failed after $RETRIES attempts"
                  exit 1
                fi
              fi
            done
          fi

          echo "✓ Successfully created and verified multi-arch manifest(s)"
