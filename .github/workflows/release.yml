# Release Workflow - Finalize, Build, Test, and Publish
#
# Unified release workflow that handles the complete release process:
# 1. Validate: Check all prerequisites (PR status, CI passed, CHANGELOG ready)
# 2. Finalize: Set release date in CHANGELOG, trigger PR doc sync
# 3. Build & Test: Build and test images for all architectures
# 4. Publish: Create tag and publish images only if all tests pass
# 5. Rollback (on failure): Revert changes and create issue
#
# Design: Everything happens in one workflow dispatch before creating the tag.
# This ensures no broken releases are tagged.

name: Release

on:  # yamllint disable-line rule:truthy
  workflow_dispatch:
    inputs:
      version:
        description: 'Semantic version to release (e.g., 1.2.3)'
        required: true
        type: string
      architectures:
        description: 'Architectures to build (comma-separated: amd64,arm64)'
        required: false
        default: 'amd64,arm64'
        type: string
      dry-run:
        description: 'Validate without making changes'
        required: false
        default: false
        type: boolean
      git-user-name:
        description: 'Git user name for commits'
        required: false
        default: 'vigOS Release Bot'
        type: string
      git-user-email:
        description: 'Git user email for commits'
        required: false
        default: 'release@vig-os.local'
        type: string

concurrency:
  # Prevent multiple releases from running simultaneously (race conditions on tags/manifests)
  group: publish-image
  cancel-in-progress: false

permissions:
  contents: read     # safe default; jobs escalate as needed

jobs:
  validate:
    name: Validate Release
    runs-on: ubuntu-22.04
    timeout-minutes: 10
    outputs:
      version: ${{ steps.vars.outputs.version }}
      pr_number: ${{ steps.pr.outputs.pr_number }}
      release_date: ${{ steps.vars.outputs.release_date }}
      build_timestamp: ${{ steps.vars.outputs.build_timestamp }}
      release_url: ${{ steps.vars.outputs.release_url }}
      pre_finalize_sha: ${{ steps.pre_sha.outputs.pre_finalize_sha }}
      matrix: ${{ steps.matrix.outputs.matrix }}
      architectures: ${{ steps.matrix.outputs.architectures }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5  # v4

      - name: Validate and prepare variables
        id: vars
        env:
          INPUT_VERSION: ${{ github.event.inputs.version }}
        run: |
          set -euo pipefail
          VERSION="$INPUT_VERSION"

          # Validate semantic version format
          if ! echo "$VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "ERROR: Invalid version format '$VERSION'"
            echo "Version must follow semantic versioning format: MAJOR.MINOR.PATCH (e.g., 1.2.3)"
            exit 1
          fi

          RELEASE_BRANCH="release/$VERSION"
          RELEASE_DATE=$(date -u +%Y-%m-%d)
          BUILD_TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          RELEASE_URL="https://github.com/${GITHUB_REPOSITORY}/releases/tag/v$VERSION"

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "release_date=$RELEASE_DATE" >> $GITHUB_OUTPUT
          echo "build_timestamp=$BUILD_TIMESTAMP" >> $GITHUB_OUTPUT
          echo "release_url=$RELEASE_URL" >> $GITHUB_OUTPUT
          echo "release_branch=$RELEASE_BRANCH" >> $GITHUB_OUTPUT

      - name: Checkout release branch
        env:
          VERSION: ${{ steps.vars.outputs.version }}
        run: |
          git fetch origin "release/$VERSION" || {
            echo "ERROR: Release branch not found: release/$VERSION"
            echo "Did you run: just prepare-release $VERSION"
            exit 1
          }
          git checkout "origin/release/$VERSION"

      - name: Record pre-finalization SHA
        id: pre_sha
        run: |
          PRE_FINALIZE_SHA=$(git rev-parse HEAD)
          echo "pre_finalize_sha=$PRE_FINALIZE_SHA" >> $GITHUB_OUTPUT
          echo "Pre-finalization SHA: $PRE_FINALIZE_SHA"

      - name: Verify CHANGELOG has TBD entry
        env:
          VERSION: ${{ steps.vars.outputs.version }}
        run: |
          if ! grep -q "## \[$VERSION\] - TBD" CHANGELOG.md; then
            echo "ERROR: CHANGELOG.md does not contain '## [$VERSION] - TBD'"
            exit 1
          fi

      - name: Verify tag does not exist
        env:
          VERSION: ${{ steps.vars.outputs.version }}
        run: |
          if git tag -l | grep -q "^v${VERSION}$"; then
            echo "ERROR: Tag v$VERSION already exists"
            exit 1
          fi

      - name: Set up GitHub CLI
        run: |
          gh version
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Find and verify PR
        id: pr
        env:
          VERSION: ${{ steps.vars.outputs.version }}
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          RELEASE_BRANCH="release/$VERSION"

          # Find PR from release branch to main
          PR_JSON=$(gh pr list \
            --head "$RELEASE_BRANCH" \
            --base main \
            --json number,isDraft,reviewDecision,statusCheckRollup \
            --limit 1)

          PR_COUNT=$(echo "$PR_JSON" | jq 'length')

          if [ "$PR_COUNT" != "1" ]; then
            if [ "$PR_COUNT" = "0" ]; then
              echo "ERROR: No PR found from $RELEASE_BRANCH to main"
              exit 1
            else
              echo "ERROR: Multiple PRs found from $RELEASE_BRANCH to main"
              exit 1
            fi
          fi

          PR_NUMBER=$(echo "$PR_JSON" | jq -r '.[0].number')
          IS_DRAFT=$(echo "$PR_JSON" | jq -r '.[0].isDraft')
          REVIEW_DECISION=$(echo "$PR_JSON" | jq -r '.[0].reviewDecision')

          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT

          if [ "$IS_DRAFT" = "true" ]; then
            echo "ERROR: PR #$PR_NUMBER is still in draft status"
            echo "Mark it ready for review first: gh pr ready $PR_NUMBER"
            exit 1
          fi

          if [ "$REVIEW_DECISION" != "APPROVED" ]; then
            echo "ERROR: PR #$PR_NUMBER does not have approvals (status: $REVIEW_DECISION)"
            exit 1
          fi

          # Check CI status
          STATUS_ROLLUP=$(echo "$PR_JSON" | jq -r '.[0].statusCheckRollup // []')
          CI_FAILED=$(echo "$STATUS_ROLLUP" | jq '[.[] | select(.conclusion == "FAILURE" or .conclusion == "ERROR")] | length')

          if [ "$CI_FAILED" != "0" ]; then
            echo "ERROR: PR #$PR_NUMBER has failed CI checks"
            echo "Fix CI issues before releasing"
            exit 1
          fi

          # Check that at least some checks have passed
          CI_SUCCESS=$(echo "$STATUS_ROLLUP" | jq '[.[] | select(.conclusion == "SUCCESS")] | length')
          if [ "$CI_SUCCESS" = "0" ]; then
            echo "ERROR: PR #$PR_NUMBER has no successful CI checks"
            echo "Ensure CI has run on the release branch"
            exit 1
          fi

          echo "✓ PR #$PR_NUMBER verified: ready and approved"

      - name: Validate and parse architectures
        id: matrix
        env:
          INPUT_ARCHITECTURES: ${{ github.event.inputs.architectures }}
        run: |
          set -euo pipefail

          ARCHS="$INPUT_ARCHITECTURES"
          echo "Input architectures: $ARCHS"

          # Remove spaces and convert to array
          ARCHS=$(echo "$ARCHS" | tr -d ' ')
          IFS=',' read -ra ARCH_ARRAY <<< "$ARCHS"

          # Validate each architecture
          VALID_ARCHS="amd64 arm64"
          VALIDATED_ARCHS=()

          for arch in "${ARCH_ARRAY[@]}"; do
            if [[ " $VALID_ARCHS " =~ " $arch " ]]; then
              VALIDATED_ARCHS+=("$arch")
              echo "✓ Valid architecture: $arch"
            else
              echo "ERROR: Invalid architecture '$arch'"
              exit 1
            fi
          done

          # Check for duplicates
          UNIQUE_ARCHS=($(echo "${VALIDATED_ARCHS[@]}" | tr ' ' '\n' | sort -u))
          if [ ${#UNIQUE_ARCHS[@]} -ne ${#VALIDATED_ARCHS[@]} ]; then
            echo "ERROR: Duplicate architectures found"
            exit 1
          fi

          # Generate matrix JSON
          MATRIX_JSON=$(printf '%s\n' "${VALIDATED_ARCHS[@]}" | jq -R . | jq -s -c '{arch: .}')

          echo "architectures=${VALIDATED_ARCHS[*]}" >> $GITHUB_OUTPUT
          echo "matrix=$MATRIX_JSON" >> $GITHUB_OUTPUT

      - name: Summary
        env:
          VERSION: ${{ steps.vars.outputs.version }}
          PR_NUMBER: ${{ steps.pr.outputs.pr_number }}
          RELEASE_DATE: ${{ steps.vars.outputs.release_date }}
          ARCHITECTURES: ${{ steps.matrix.outputs.architectures }}
          DRY_RUN: ${{ github.event.inputs.dry-run }}
        run: |
          echo "✓ All validation checks passed"
          echo ""
          echo "Release Configuration:"
          echo "  Version: $VERSION"
          echo "  Release Branch: release/$VERSION"
          echo "  PR: #$PR_NUMBER"
          echo "  Release Date: $RELEASE_DATE"
          echo "  Architectures: $ARCHITECTURES"
          echo "  Dry-run: $DRY_RUN"

  finalize:
    name: Finalize Release
    needs: validate
    runs-on: ubuntu-22.04
    timeout-minutes: 15
    if: ${{ github.event.inputs.dry-run != 'true' }}
    permissions:
      contents: write    # read release branch (fetch/reset)
      actions: write     # trigger sync-issues workflow
    outputs:
      finalize_sha: ${{ steps.finalize.outputs.finalize_sha }}

    steps:
      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@29824e69f54612133e76f7eaac726eef6c875baf  # v2
        with:
          app-id: ${{ secrets.APP_SYNC_ISSUES_ID }}
          private-key: ${{ secrets.APP_SYNC_ISSUES_PRIVATE_KEY }}

      - name: Checkout release branch
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5  # v4
        with:
          ref: release/${{ needs.validate.outputs.version }}
          token: ${{ steps.app-token.outputs.token }}
          persist-credentials: true

      - name: Set up environment
        uses: ./.github/actions/setup-env
        with:
          sync-dependencies: 'true'

      - name: Set release date in CHANGELOG
        env:
          VERSION: ${{ needs.validate.outputs.version }}
          RELEASE_DATE: ${{ needs.validate.outputs.release_date }}
        run: |
          set -euo pipefail
          uv run prepare-changelog finalize "$VERSION" "$RELEASE_DATE"
          echo "✓ Release date set in CHANGELOG.md"

      - name: Commit and push finalization changes via API
        uses: vig-os/commit-action@b70c2d87acd0f146c40e8d88a9bda40b76c084b5  # v0.1.3
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          TARGET_BRANCH: refs/heads/release/${{ needs.validate.outputs.version }}
          COMMIT_MESSAGE: |-
            chore: finalize release ${{ needs.validate.outputs.version }}

            Set release date to ${{ needs.validate.outputs.release_date }} in CHANGELOG.md

            Refs: #${{ needs.validate.outputs.pr_number }}
          FILE_PATHS: CHANGELOG.md

      - name: Trigger sync-issues workflow
        env:
          GH_TOKEN: ${{ github.token }}
          VERSION: ${{ needs.validate.outputs.version }}
        run: |
          set -euo pipefail
          echo "Triggering sync-issues workflow..."
          gh workflow run sync-issues.yml \
            -f "target-branch=release/$VERSION"
          echo "✓ sync-issues workflow triggered"

      - name: Wait for sync-issues completion
        run: |
          set -euo pipefail
          TIMEOUT=120
          ELAPSED=0
          INTERVAL=10

          sleep 5
          ELAPSED=5

          while [ $ELAPSED -lt $TIMEOUT ]; do
            RUN_STATUS=$(gh run list \
              --workflow sync-issues.yml \
              --limit 1 \
              --json status,conclusion \
              --jq '.[0].status' 2>/dev/null || echo "unknown")

            if [ "$RUN_STATUS" = "completed" ]; then
              RUN_CONCLUSION=$(gh run list \
                --workflow sync-issues.yml \
                --limit 1 \
                --json conclusion \
                --jq '.[0].conclusion' 2>/dev/null || echo "unknown")

              if [ "$RUN_CONCLUSION" = "success" ]; then
                echo "✓ sync-issues workflow completed successfully"
              else
                echo "⚠ sync-issues workflow completed with status: $RUN_CONCLUSION"
              fi
              break
            fi

            sleep "$INTERVAL"
            ELAPSED=$((ELAPSED + INTERVAL))
            echo "Waiting for sync-issues... (${ELAPSED}s / ${TIMEOUT}s)"
          done

          if [ $ELAPSED -ge $TIMEOUT ]; then
            echo "⚠ Timed out waiting for sync-issues workflow"
            echo "The release may continue, but PR documentation may not be synced"
          fi

        env:
          GH_TOKEN: ${{ github.token }}

      - name: Pull sync-issues changes
        env:
          VERSION: ${{ needs.validate.outputs.version }}
        run: |
          set -euo pipefail
          git fetch origin "release/$VERSION"
          git reset --hard "origin/release/$VERSION"
          echo "✓ Synced with remote release branch"

      - name: Output finalize SHA
        id: finalize
        run: |
          FINALIZE_SHA=$(git rev-parse HEAD)
          echo "finalize_sha=$FINALIZE_SHA" >> $GITHUB_OUTPUT
          echo "Finalized at commit: $FINALIZE_SHA"

  build-and-test:
    name: Build and Test (${{ matrix.arch }})
    needs: [validate, finalize]
    runs-on: ${{ matrix.arch == 'amd64' && 'ubuntu-22.04' || 'ubuntu-22.04-arm' }}
    timeout-minutes: 60
    strategy:
      matrix: ${{ fromJson(needs.validate.outputs.matrix) }}
      fail-fast: true

    steps:
      - name: Checkout release commit
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5  # v4
        with:
          ref: ${{ needs.finalize.outputs.finalize_sha }}

      - name: Build container image
        id: build
        uses: ./.github/actions/build-image
        with:
          version: ${{ needs.validate.outputs.version }}
          arch: ${{ matrix.arch }}
          release-date: ${{ needs.validate.outputs.release_date }}
          release-url: ${{ needs.validate.outputs.release_url }}
          build-timestamp: ${{ needs.validate.outputs.build_timestamp }}
          vcs-ref: ${{ github.sha }}
          output-type: tar
          output-file: /tmp/image.tar

      - name: Run image tests
        uses: ./.github/actions/test-image
        with:
          image-tag: ${{ needs.validate.outputs.version }}-${{ matrix.arch }}
          image-source: tar
          tar-file: /tmp/image.tar

      - name: Run integration tests
        uses: ./.github/actions/test-integration
        with:
          image-tag: ${{ needs.validate.outputs.version }}-${{ matrix.arch }}

      - name: Scan image for vulnerabilities
        uses: aquasecurity/trivy-action@b6643a29fecd7f34b3597bc6acb0a98b03d33ff8  # v0.33.1
        with:
          input: /tmp/image.tar
          format: 'table'
          severity: 'HIGH,CRITICAL'
          exit-code: '1'
          ignore-unfixed: true
          trivyignores: '.trivyignore'

      - name: Upload tested image
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02  # v4
        with:
          name: container-image-${{ needs.validate.outputs.version }}-${{ matrix.arch }}
          path: /tmp/image.tar
          retention-days: 1
          compression-level: 0

      - name: Summary
        run: |
          echo "✓ Build, tests, and security scan passed for ${{ matrix.arch }}"

  publish:
    name: Publish Release
    needs: [validate, finalize, build-and-test]
    runs-on: ubuntu-22.04
    timeout-minutes: 30
    permissions:
      contents: write       # create and push tags
      packages: write       # push images to GHCR
      id-token: write       # keyless cosign signing via OIDC
      attestations: write   # build provenance attestations

    steps:
      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@29824e69f54612133e76f7eaac726eef6c875baf  # v2
        with:
          app-id: ${{ secrets.APP_SYNC_ISSUES_ID }}
          private-key: ${{ secrets.APP_SYNC_ISSUES_PRIVATE_KEY }}

      - name: Checkout release commit
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5  # v4
        with:
          ref: ${{ needs.finalize.outputs.finalize_sha }}
          token: ${{ steps.app-token.outputs.token }}
          persist-credentials: true

      - name: Configure git
        env:
          GIT_USER_NAME: ${{ github.event.inputs.git-user-name }}
          GIT_USER_EMAIL: ${{ github.event.inputs.git-user-email }}
        run: |
          git config user.name "$GIT_USER_NAME"
          git config user.email "$GIT_USER_EMAIL"

      - name: Create annotated tag
        env:
          VERSION: ${{ needs.validate.outputs.version }}
        run: |
          set -euo pipefail
          git tag -a "v$VERSION" -m "Release $VERSION"
          echo "✓ Tag created: v$VERSION"

      - name: Push tag
        env:
          VERSION: ${{ needs.validate.outputs.version }}
        run: |
          git push origin "v$VERSION"
          echo "✓ Tag pushed"

      - name: Install cosign
        uses: sigstore/cosign-installer@faadad0cce49287aee09b3a48701e75088a2c6ad  # v4

      - name: Login to GitHub Container Registry
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9  # v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ github.token }}

      - name: Download image artifacts
        uses: actions/download-artifact@d3f86a106a0bac45b974a628896c90dbdf5c8093  # v4
        with:
          path: /tmp/images
          pattern: container-image-${{ needs.validate.outputs.version }}-*

      - name: Load and push images
        env:
          VERSION: ${{ needs.validate.outputs.version }}
          ARCHS: ${{ needs.validate.outputs.architectures }}
        run: |
          set -euo pipefail
          REPO="ghcr.io/vig-os/devcontainer"

          IFS=' ' read -ra ARCH_ARRAY <<< "$ARCHS"

          for arch in "${ARCH_ARRAY[@]}"; do
            ARTIFACT_PATH="/tmp/images/container-image-${VERSION}-${arch}"

            if [ ! -f "$ARTIFACT_PATH/image.tar" ]; then
              echo "ERROR: Artifact not found: $ARTIFACT_PATH/image.tar"
              ls -lh /tmp/images/
              exit 1
            fi

            echo "Loading $arch image..."
            docker load < "$ARTIFACT_PATH/image.tar"

            IMAGE_TAG="$REPO:$VERSION-$arch"
            echo "Pushing $arch image: $IMAGE_TAG"

            RETRIES=3
            for i in $(seq 1 $RETRIES); do
              if docker push "$IMAGE_TAG"; then
                echo "✓ Pushed: $IMAGE_TAG"
                break
              else
                if [ $i -lt $RETRIES ]; then
                  echo "Push failed, retrying ($i/$RETRIES)..."
                  sleep 3
                else
                  echo "ERROR: Failed to push after $RETRIES attempts"
                  exit 1
                fi
              fi
            done
          done

      - name: Create multi-arch manifest
        env:
          VERSION: ${{ needs.validate.outputs.version }}
          ARCHS: ${{ needs.validate.outputs.architectures }}
        run: |
          set -euo pipefail
          REPO="ghcr.io/vig-os/devcontainer"

          IFS=' ' read -ra ARCH_ARRAY <<< "$ARCHS"

          # Build image list for manifest
          ARCH_IMAGES=()
          for arch in "${ARCH_ARRAY[@]}"; do
            ARCH_IMAGES+=("$REPO:$VERSION-$arch")
            echo "Including in manifest: $REPO:$VERSION-$arch"
          done

          echo "Creating version manifest: $REPO:$VERSION"
          RETRIES=3
          for i in $(seq 1 $RETRIES); do
            if docker buildx imagetools create \
              --tag "$REPO:$VERSION" \
              "${ARCH_IMAGES[@]}"; then
              echo "✓ Created version manifest: $REPO:$VERSION"
              break
            else
              if [ $i -lt $RETRIES ]; then
                echo "Manifest creation failed, retrying ($i/$RETRIES)..."
                sleep 3
              else
                echo "ERROR: Failed to create version manifest"
                exit 1
              fi
            fi
          done

          # Update latest manifest only if building both architectures
          if [ ${#ARCH_ARRAY[@]} -eq 2 ]; then
            echo "Creating/updating latest manifest: $REPO:latest"

            RETRIES=3
            for i in $(seq 1 $RETRIES); do
              if docker buildx imagetools create \
                --tag "$REPO:latest" \
                "${ARCH_IMAGES[@]}"; then
                echo "✓ Created/updated latest manifest: $REPO:latest"
                break
              else
                if [ $i -lt $RETRIES ]; then
                  echo "Latest manifest creation failed, retrying ($i/$RETRIES)..."
                  sleep 3
                else
                  echo "ERROR: Failed to create latest manifest"
                  exit 1
                fi
              fi
            done
          else
            echo "Skipping 'latest' manifest (single architecture or limited build)"
          fi

      - name: Verify manifests
        env:
          VERSION: ${{ needs.validate.outputs.version }}
          ARCHS: ${{ needs.validate.outputs.architectures }}
        run: |
          set -euo pipefail
          REPO="ghcr.io/vig-os/devcontainer"

          IFS=' ' read -ra ARCH_ARRAY <<< "$ARCHS"

          echo "Verifying version manifest: $REPO:$VERSION"
          RETRIES=5
          for i in $(seq 1 $RETRIES); do
            if docker buildx imagetools inspect "$REPO:$VERSION" >/dev/null 2>&1; then
              echo "✓ Version manifest verified"
              break
            else
              if [ $i -lt $RETRIES ]; then
                echo "Verification failed, retrying ($i/$RETRIES)..."
                sleep 5
              else
                echo "ERROR: Version manifest verification failed"
                exit 1
              fi
            fi
          done

          if [ ${#ARCH_ARRAY[@]} -eq 2 ]; then
            echo "Verifying latest manifest: $REPO:latest"
            RETRIES=5
            for i in $(seq 1 $RETRIES); do
              if docker buildx imagetools inspect "$REPO:latest" >/dev/null 2>&1; then
                echo "✓ Latest manifest verified"
                break
              else
                if [ $i -lt $RETRIES ]; then
                  echo "Verification failed, retrying ($i/$RETRIES)..."
                  sleep 5
                else
                  echo "ERROR: Latest manifest verification failed"
                  exit 1
                fi
              fi
            done
          fi

      - name: Generate SBOM
        uses: anchore/sbom-action@28d71544de8eaf1b958d335707167c5f783590ad  # v0.22.2
        with:
          image: ghcr.io/vig-os/devcontainer:${{ needs.validate.outputs.version }}
          artifact-name: sbom-${{ needs.validate.outputs.version }}.spdx.json
          output-file: /tmp/sbom.spdx.json
          format: spdx-json

      - name: Upload SBOM artifact
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02  # v4
        with:
          name: sbom-${{ needs.validate.outputs.version }}
          path: /tmp/sbom.spdx.json
          retention-days: 90

      - name: Sign container image with cosign
        env:
          VERSION: ${{ needs.validate.outputs.version }}
        run: |
          set -euo pipefail
          REPO="ghcr.io/vig-os/devcontainer"

          # Get the digest for the multi-arch manifest
          DIGEST=$(docker buildx imagetools inspect "$REPO:$VERSION" --format '{{json .Manifest.Digest}}' | tr -d '"')
          echo "Signing image: $REPO@$DIGEST"

          # Keyless signing using GitHub Actions OIDC identity
          cosign sign --yes "$REPO@$DIGEST"
          echo "✓ Image signed with cosign (keyless)"

      - name: Capture image digest for attestation
        id: digest
        env:
          VERSION: ${{ needs.validate.outputs.version }}
        run: |
          REPO="ghcr.io/vig-os/devcontainer"
          DIGEST=$(docker buildx imagetools inspect "$REPO:$VERSION" --format '{{json .Manifest.Digest}}' | tr -d '"')
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT
          echo "Image digest: $DIGEST"

      - name: Attest build provenance
        uses: actions/attest-build-provenance@96278af6caaf10aea03fd8d33a09a777ca52d62f  # v3
        with:
          subject-name: ghcr.io/vig-os/devcontainer
          subject-digest: ${{ steps.digest.outputs.digest }}
          push-to-registry: true

      - name: Attest SBOM
        uses: actions/attest-sbom@4651f806c01d8637787e274ac3bdf724ef169f34  # v3
        with:
          subject-name: ghcr.io/vig-os/devcontainer
          subject-digest: ${{ steps.digest.outputs.digest }}
          sbom-path: /tmp/sbom.spdx.json
          push-to-registry: true

      - name: Summary
        env:
          VERSION: ${{ needs.validate.outputs.version }}
        run: |
          echo "✓ Release published successfully!"
          echo ""
          echo "Release Summary:"
          echo "  Version: $VERSION"
          echo "  Tag: v$VERSION"
          echo "  Images:"
          echo "    - ghcr.io/vig-os/devcontainer:$VERSION"
          echo "    - ghcr.io/vig-os/devcontainer:latest"
          echo "  Security:"
          echo "    - Cosign signature attached"
          echo "    - SLSA build provenance attested"
          echo "    - SBOM (SPDX) generated and attested"
          echo ""
          echo "Next steps:"
          echo "  1. Merge release PR to main (triggers post-release workflow automatically)"

  rollback:
    name: Rollback on Failure
    needs: [validate, finalize, build-and-test, publish]
    runs-on: ubuntu-22.04
    timeout-minutes: 10
    if: failure()
    permissions:
      issues: write          # create failure issue

    steps:
      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@29824e69f54612133e76f7eaac726eef6c875baf  # v2
        with:
          app-id: ${{ secrets.APP_SYNC_ISSUES_ID }}
          private-key: ${{ secrets.APP_SYNC_ISSUES_PRIVATE_KEY }}

      - name: Rollback release branch
        id: rollback-branch
        continue-on-error: true
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          VERSION: ${{ needs.validate.outputs.version }}
          PRE_SHA: ${{ needs.validate.outputs.pre_finalize_sha }}
        run: |
          set -euo pipefail
          echo "Rolling back release branch to pre-finalization state..."
          gh api "repos/${{ github.repository }}/git/refs/heads/release/$VERSION" \
            -X PATCH \
            -f sha="$PRE_SHA" \
            -F force=true
          echo "✓ Release branch rolled back to $PRE_SHA"

      - name: Delete tag if created
        id: rollback-tag
        continue-on-error: true
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          VERSION: ${{ needs.validate.outputs.version }}
        run: |
          set -euo pipefail
          TAG="v$VERSION"
          if gh api "repos/${{ github.repository }}/git/refs/tags/$TAG" >/dev/null 2>&1; then
            echo "Deleting remote tag: $TAG"
            gh api "repos/${{ github.repository }}/git/refs/tags/$TAG" -X DELETE
            echo "✓ Tag deleted"
          else
            echo "Tag does not exist on remote (not created)"
          fi

      - name: Create failure issue
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b  # v7
        with:
          script: |
            const version = '${{ needs.validate.outputs.version }}';
            const workflowUrl = `${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`;
            const prNumber = ${{ needs.validate.outputs.pr_number || 'null' }};

            let failedJobs = [];
            if ('${{ needs.validate.result }}' !== 'success') failedJobs.push('validate');
            if ('${{ needs.finalize.result }}' !== 'success') failedJobs.push('finalize');
            if ('${{ needs.build-and-test.result }}' !== 'success') failedJobs.push('build-and-test');
            if ('${{ needs.publish.result }}' !== 'success') failedJobs.push('publish');

            const rollbackBranch = '${{ steps.rollback-branch.outcome }}';
            const rollbackTag = '${{ steps.rollback-tag.outcome }}';

            const title = `Release ${version} failed -- automatic rollback`;
            const body = `
            Release ${version} encountered an error during the automated release workflow.

            **Failed Jobs:** ${failedJobs.join(', ')}

            **Workflow Run:** [View logs](${workflowUrl})

            **Release PR:** #${prNumber}

            **Rollback Results:**
            - Branch rollback: ${rollbackBranch}
            - Tag deletion: ${rollbackTag}

            **Actions Taken:**
            - Release branch rolled back to pre-finalization state
            - Release tag deleted (if created)
            - This issue created for investigation

            **Manual Cleanup May Be Needed:**
            - If images were pushed to GHCR before the failure, they are **not** automatically deleted. Check \`ghcr.io/vig-os/devcontainer:${version}-*\` and remove any orphaned images manually.

            **Next Steps:**
            1. Review the workflow logs to identify the root cause
            2. Check rollback results above; fix any partial rollback manually
            3. Fix the issue on the release branch
            4. Re-run the workflow when ready

            For details, check the workflow run linked above.
            `;

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title,
              body,
              labels: ['bug', 'release']
            });

            console.log(`Created issue: ${title}`);

      - name: Summary
        run: |
          echo "✗ Release workflow failed"
          echo ""
          echo "Automatic rollback completed:"
          echo "  - Release branch reset to pre-finalization state"
          echo "  - Release tag deleted (if created)"
          echo "  - GitHub issue created for investigation"
          echo ""
          echo "Check the workflow logs and issue for details"
