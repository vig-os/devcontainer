---
type: pull_request
state: open
branch: feature/67-declarative-sync-manifest → dev
created: 2026-02-18T00:58:00Z
updated: 2026-02-18T08:14:40Z
author: gerchowl
author_url: https://github.com/gerchowl
url: https://github.com/vig-os/devcontainer/pull/68
comments: 3
labels: none
assignees: none
milestone: none
projects: none
relationship: none
synced: 2026-02-18T08:23:27.099Z
---

# [PR 68](https://github.com/vig-os/devcontainer/pull/68) feat: agent-driven development workflows, templates, and declarative sync manifest

## Summary

- Add 14 Cursor commands (start-issue, tdd, debug, review, submit-pr, etc.) and 2 Cursor rules (coding-principles, tdd) for agent-driven development workflows (#63)
- Add agent-friendly issue templates, changelog Cursor rule, and PR template enhancements (#61)
  - New templates: `refactor.yml`, `documentation.yml`, `ci_build.yml`, `config.yml`
  - New rule: `.cursor/rules/changelog.mdc` (always applied)
  - PR template enhanced with Changelog Entry section and CI/Build change type
- Replace the dual sync system (`sync-manifest.txt` + bash function in `prepare-build.sh`, and `sync-workspace.sh` shell script) with a single declarative Python manifest (`scripts/sync_manifest.py`) (#67)
- Sync Cursor rules, commands, GitHub templates, dependabot config, and pre-commit config into `assets/workspace/` with automated transformations
- Update `test_manifest_files` to skip checksum verification for intentionally transformed entries

Closes #61
Closes #63
Closes #67

### Key files

| File | Purpose |
|------|---------|
| `scripts/sync_manifest.py` | Declarative manifest: what to sync + transforms |
| `.cursor/commands/*.md` | 14 new agent workflow commands |
| `.cursor/rules/*.mdc` | 3 new always-on rules (coding-principles, tdd, changelog) |
| `.github/ISSUE_TEMPLATE/*.yml` | 6 issue templates + config.yml |
| `.github/pull_request_template.md` | Enhanced PR template |
| `scripts/prepare-build.sh` | Now calls `sync_manifest.py` instead of bash function |

### Transforms applied to workspace template

- `.pre-commit-config.yaml`: remove `generate-docs` hook, generalize Bandit paths, comment out `validate-commit-msg` args
- `.github/dependabot.yml`: remove Docker ecosystem section
- `.cursor/rules/commit-messages.mdc`: remove repo-specific doc link
- `.cursor/commands/tdd.md`, `verify.md`: generalize test recipe names

## Test plan

- [ ] CI passes (build image, project checks, image tests, integration tests)
- [ ] `just sync-workspace` produces correct output
- [ ] `uv run python scripts/sync_manifest.py list --transformed` shows 4 transformed entries
- [ ] YAML validation passes on generated workspace `.pre-commit-config.yaml` and `dependabot.yml`
- [ ] New issue templates render correctly on GitHub


---
---

## Comments (3)

### [Comment #1](https://github.com/vig-os/devcontainer/pull/68#issuecomment-3919321616) by [@gerchowl](https://github.com/gerchowl)

_Posted on February 18, 2026 at 08:11 AM_

## Idea: Use GitHub issue bodies for implementation plan tracking instead of `docs/plans/` files

The current `/plan` command writes plans to `docs/plans/YYYY-MM-DD-<name>-plan.md` and `/execute-plan` reads from there. An alternative approach: write and track the implementation plan directly in the **GitHub issue body** (using task lists / checkboxes), and have the agent update task status there as work progresses.

### How it would work

- `/plan` reads the issue, breaks it into tasks, then **appends or replaces a "## Implementation Plan" section** in the issue body (via `gh issue edit --body`).
- `/execute-plan` reads the issue body, picks up unchecked tasks, executes them, and **checks them off** in the issue body as they complete.
- The issue becomes the single source of truth for both *what* needs doing and *what's done*.

### Pros of issue-body plans

| | |
|---|---|
| **Single source of truth** | Plan lives where the work is tracked — no separate file to keep in sync with the issue. |
| **Visible to the whole team** | Anyone looking at the issue instantly sees progress — no need to find and read a local `docs/plans/` file or check it out. |
| **No repo clutter** | Avoids accumulating plan markdown files in `docs/plans/` that become stale after merge. |
| **GitHub-native progress** | Task lists in issue bodies render as progress bars in issue lists and project boards. |
| **Cross-agent continuity** | A new agent session (or different worktree) can pick up where the last left off — just read the issue body. No need to find the right plan file. |
| **Audit trail via issue edit history** | GitHub tracks every edit to the issue body, so you get a changelog of plan evolution for free. |

### Cons / risks of issue-body plans

| | |
|---|---|
| **API rate limits** | Frequent `gh issue edit` calls (after every 2-3 task batch) could hit GitHub API rate limits, especially with multiple agents. |
| **Concurrent edit conflicts** | If two agents or a human edit the issue body at the same time, last-write-wins — edits can be lost. `docs/plans/` files at least get merge conflict detection via git. |
| **Size limits** | GitHub issue bodies have a ~65k character limit. Complex plans with detailed sub-tasks could get close. Plan files have no practical limit. |
| **Less structured** | Markdown in an issue body is harder to parse reliably than a dedicated plan file with a known schema. Edge cases in formatting could trip up the agent. |
| **Offline / local-first workflows** | Plan files work without network access; issue-body plans require connectivity for every read/write. |
| **Pollutes issue body** | The issue body serves double duty (problem description + implementation plan), which can make it long and harder for humans to scan. A `<details>` collapse could mitigate this. |
| **`/plan` origin (superpowers repo)** | The current `/plan` + `/execute-plan` pattern comes from the [superpowers](https://github.com/rileytomasek/cursor-superpowers) community repo. Keeping the file-based approach means we stay compatible with that ecosystem and its updates. Diverging means maintaining our own variant. |

### Possible hybrid approach

Use **both**: write a concise task checklist into the issue body for visibility and cross-agent continuity, but keep the detailed plan (file paths, verification steps, dependencies) in `docs/plans/` for structured parsing and offline use. The issue body becomes the "dashboard" and the plan file is the "spec".

---

Worth discussing whether the visibility and cross-agent continuity benefits outweigh the API/concurrency risks, or whether a hybrid gives us the best of both worlds.

---

### [Comment #2](https://github.com/vig-os/devcontainer/pull/68#issuecomment-3919327460) by [@gerchowl](https://github.com/gerchowl)

_Posted on February 18, 2026 at 08:12 AM_

**Correction on the "offline" con above:** The offline/local-first argument is pretty much irrelevant — the agents require network access anyway (GitHub API, MCP servers, tool calls, etc.). If the network is down, the agent can't work regardless of where the plan lives. So that con effectively drops off the list.

---

### [Comment #3](https://github.com/vig-os/devcontainer/pull/68#issuecomment-3919336528) by [@gerchowl](https://github.com/gerchowl)

_Posted on February 18, 2026 at 08:14 AM_

**Additional thought: tie `/plan` to issue context as a precondition**

Rather than allowing `/plan` to run in isolation, we should enforce that a plan can only be created/executed when the agent is **already on an issue branch** (or runs `/start-issue` first to get on one). This means:

1. `/plan` checks that the current branch matches `<type>/<issue_number>-*` (per our branch naming convention).
2. If not on an issue branch, it refuses and tells the agent to run `/start-issue` first.
3. The plan is then inherently scoped to that issue — the issue number is known, the issue body is accessible, and there's no ambiguity about *what* the plan is for.

**Why this matters for the issue-body approach:**

- If `/plan` always knows which issue it's working on, writing the plan into the issue body becomes trivial — no guessing, no "which issue?" prompts.
- It also prevents orphaned plan files in `docs/plans/` that aren't tied to any issue.
- The workflow becomes: `/start-issue` → `/plan` (writes to issue body) → `/execute-plan` (reads from issue body, checks off tasks) → `/submit-pr`. Clean linear pipeline, single source of truth throughout.

**This also works with the file-based approach** — even if we keep `docs/plans/`, gating `/plan` behind issue context means the plan file can be named `docs/plans/<issue_number>-<summary>-plan.md` and always references back to its issue. But it makes the argument for issue-body plans stronger since the issue is already the anchor point.

---

